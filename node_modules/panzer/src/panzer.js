/*!
 * Panzer v0.3.13 by Bemi Faison
 * http://github.com/bemson/Panzer
 *
 * Dependencies:
 * genData v3.1.0 / Bemi Faison / MIT / http://github.com/bemson/genData
 *
 * Copyright 2012, Bemi Faison
 * Released under the MIT License
 */
!function (inAMD, inCJS, Array, Object, RegExp, scope, undefined) {

  // dependent module initializer
  function initPanzer(require) {
    var
      Panzer = {
        // public method to return a Panzer class
        create: function () {
          var
            // platform configuration
            panzer = {
              pkgs: [],
              pkgsIdx: {},
              KlassProxy: function () {},
              Klass: Klass
            };

          function Klass(rawtree, klassConfig) {
            if (!(this instanceof Klass)) {
              throw new Error('Missing new operator.');
            }
            // define corresponding privileged instance
            new Tree(panzer, this, rawtree, typeof klassConfig === 'object' ? klassConfig : {});
          }
          Klass.prototype = panzer.KlassProxy.prototype;

          // Klass package manager
          Klass.pkg = function () {
            return ResolveOrRegisterKlassPackage.apply(panzer, arguments);
          };

          return Klass;
        },
        version: '0.3.10'
      },
      genData = (inCJS || inAMD) ? require('genData') : scope.genData,
      panzerInstanceCount = 0,
      postCallbackCount = 0,
      ObjecttoStringResult = ({}).toString(),
      // build node-tree
      genNodes = genData.spawn(
        function (name, value, parent, flags) {
          var
            node = this,
            panzer = flags.args[0],
            keyTestMap = flags.args[1],
            nodes = flags.returns,
            isBadKey = keyTestMap && name &&
              (keyTestMap.nf.some(passKeyFnc) || keyTestMap.nr.some(passKeyRxp)),
            isAttrKey = keyTestMap && name &&
              (keyTestMap.af.some(passKeyFnc) || keyTestMap.ar.some(passKeyRxp)),
            alternateSourceObject,
            pkg,
            pkgIdx = 0
          ;

          function passKeyFnc(badFnc) {
            return badFnc.call(scope, name, value);
          }
          function passKeyRxp(badRxp) {
            return badRxp.test(name);
          }

          if (isBadKey || isAttrKey) {
            // don't scan further
            flags.source = 0;

            if (isAttrKey) {
              parent.attrs[name] = value;
            }
          } else {

            // init properties (for faster lookups)
            node.parentIndex =
            node.previousIndex =
            node.nextIndex =
            node.firstChildIndex =
            node.lastChildIndex =
            node.childIndex =
            node.ctx =
            node.lte =
              -1;
            node.index = nodes.push(node);
            node.depth = parent ? parent.depth + 1 : 1;
            node.name = name || 'PROOT';
            node.attrs = {};
            node.path = parent ? parent.path + name + '/' : '//';
            node.children = [];

            // set hierarchy-related properties
            if (parent) {

              node.parentIndex = parent.index;
              if (!parent.children.length) {
                parent.firstChildIndex = node.index;
              }
              node.childIndex = parent.children.push(node.index) - 1;
              parent.lastChildIndex = node.index;

              // update younger sibling
              if (node.childIndex) {
                node.previousIndex = parent.children[node.childIndex - 1];
                nodes[node.previousIndex - 1].nextIndex = node.index;
              }

            } else {
              // capture original object (for node prep calls)
              flags.tree = value;
            }
            // let each packager alter this node's structure
            if (panzer && panzer.pkgs.length) {
              for (; pkg = panzer.pkgs[pkgIdx]; pkgIdx++) {
                if (
                  typeof pkg.def.prepNode === 'function' &&
                  typeof (alternateSourceObject = pkg.def.prepNode.call(scope, flags.source, flags.tree)) !== 'undefined'
                ) {
                  flags.source = alternateSourceObject;
                }
              }
            }
          }
        }
      ),
      // clone nodes generated by genNodes
      genCloneNodes = genData.spawn(
        function (name, originalNode, parent, flags) {
          var
            node = this,
            member
          ;
          if (parent) {
            // don't scan further
            flags.source = 0;

            // copy non-tracking members from this node
            for (member in originalNode) {
              if (originalNode.hasOwnProperty(member) && member !== 'lte' && member !== 'ctx') {
                node[member] = originalNode[member];
              }
            }
            // add to the cloned array
            return node;
          }
        }
      ),
      r_hasAlphanumeric = /\w/
    ;

    // private Tree instance
    function Tree(panzer, proxyInst, rawtree, klassConfig) {
      var
        tree = this,
        pkgProxyIdx = {},
        pkgInstIdx = {},
        keyTestMap = {
          af: [],   // attribute function tests
          ar: [],   // attribute regexp tests
          nf: [],   // node function tests
          nr: []    // node regexp tests
        },
        forLoopIdx,
        forLoopLength,
        forLoopItem,
        tmp
      ;

      // get the package instance corresponding this panzer
      function proxyToStringMethod(platform, pkgIdx) {
        if (platform === panzer && pkgIdx < tree.pkgs.length) {
          return tree.pkgs[pkgIdx].inst;
        }

        // emulate normal toString behavior
        return ObjecttoStringResult;
      }

      // catalog package key tests and preprocess the tree
      for (forLoopIdx = 0; forLoopItem = panzer.pkgs[forLoopIdx]; forLoopIdx++) {
        // cache package key tests schemes
        if (typeof forLoopItem.def.attrKey === 'function') {
          keyTestMap.af.push(forLoopItem.def.attrKey);
        } else if (forLoopItem.def.attrKey instanceof RegExp) {
          keyTestMap.ar.push(forLoopItem.def.attrKey);
        }
        if (typeof forLoopItem.def.badKey === 'function') {
          keyTestMap.nf.push(forLoopItem.def.badKey);
        } else if (forLoopItem.def.badKey instanceof RegExp) {
          keyTestMap.nr.push(forLoopItem.def.badKey);
        }

        if (
          typeof forLoopItem.def.prepTree === 'function' &&
          typeof (tmp = forLoopItem.def.prepTree.call(scope, rawtree)) !== 'undefined'
        ) {
          rawtree = tmp;
        }
      }

      // compile canonical node-tree
      tree.nodes = genNodes(rawtree, panzer, keyTestMap);

      // point tree node to it's own root
      tree.nodes[0].parentIndex =
      tree.nodes[0].childIndex =
        0;

      // build contrived "null" node
      tree.nodes.unshift(genNodes()[0]);
      tree.nodes[0].children.push(1);
      tree.nodes[0].name = 'PNULL';
      tree.nodes[0].index =
      tree.nodes[0].depth =
      tree.nodes[0].lte =
        0;
      tree.nodes[0].path = '..//';
      tree.nodes[0].firstChildIndex =
      tree.nodes[0].lastChildIndex =
        1;
      tree.nodes[0].ctx = 1;

      // privileged package api for controlling this tank
      tree.tank = {
        id: panzerInstanceCount++,
        currentIndex: 0,
        targetIndex: -1,

        // direct tank to a node
        go: function (tgtIndex) {
          var tgtNode = tree.nodes[tgtIndex];
          if (tgtNode) {
            tree.target = tgtNode;
            tree.tank.targetIndex = tgtNode.index;
          }
          tree.stop = 0;
          return tree.go();
        },

        // stop the tank
        stop: function () {
          // set internal stop flag
          tree.stop = 1;
          // return truthy when this tree is in a loop, otherwise falsy
          return !!tree.loop;
        },

        // manage post navigation callbacks
        post: function (param) {
          var paramType = typeof param;

          if (tree.loop) {
            if (paramType === 'function') {
              // add callback and return id
              tree.posts[++postCallbackCount] = param;
              return postCallbackCount;
            } else if (paramType === 'number') {
              if (tree.posts.hasOwnProperty(param)) {
                // remove callback with this id
                delete tree.posts[param];
                return true;
              }
            }
          }

          return false;
        }
      };
      tree.posts = {};
      tree.current = tree.nodes[0];
      tree.target =
      tree.loop =
        0;

      // compose package instances
      tree.pkgs = panzer.pkgs.map(function (pkg) {
        var
          pkgName = pkg.name,
          pkgDef = pkg.def,
          // package-instance confguration
          pkgEntry = {
            name: pkgName,
            idx: pkg.idx,
            pkg: pkg,
            inst: new pkgDef()
          }
        ;

        // define constructor to mirror this package's proxy prototype
        function pkgProxy() {}
        pkgProxy.prototype = pkg.proxy.prototype;

        // index instances for sharing
        pkgProxyIdx[pkgName] = pkgEntry.proxy = new pkgProxy();
        pkgInstIdx[pkgName] = pkgEntry.inst;

        // compose package-proxy
        pkgEntry.proxy.pkgs = pkgProxyIdx;
        pkgEntry.proxy.toString = proxyToStringMethod;

        // compose package-instance
        pkgEntry.inst.pkgs = pkgInstIdx;
        pkgEntry.inst.tank = tree.tank;
        pkgEntry.inst.nodes = genCloneNodes.call(pkg.node, tree.nodes);

        return pkgEntry;
      });

      // expose public proxy to package-instances
      for (forLoopIdx = 0; forLoopItem = tree.pkgs[forLoopIdx]; forLoopIdx++) {
        forLoopItem.inst.proxy = proxyInst;
      }

      // compose public proxy instance
      proxyInst.pkgs = pkgProxyIdx;
      proxyInst.toString = proxyToStringMethod;

      // disable tank events while initializing
      tree.fire = goodForNothinFunction;
      for (forLoopIdx = 0; forLoopItem = tree.pkgs[forLoopIdx]; forLoopIdx++) {
        if (typeof forLoopItem.pkg.def.init === 'function') {
          forLoopItem.pkg.def.init.call(forLoopItem.inst, klassConfig);
        }
      }
      delete tree.fire;
    }
    Tree.prototype = {

      // navigate towards a target node
      go: function () {
        var
          tree = this,
          nodes = tree.nodes,
          tank = tree.tank,
          postId,
          dir,
          inCurrentNode,
          traversalCount = 0,
          resuming = tree.stopped,
          curNode = tree.current,
          nextPhase = resuming ? curNode.lte : -1,
          nextNodeIndex = -1,
          lastTargetIndex = resuming ? tree.target.index : null,
          nodeEngaged,
          endEventFired
        ;

        // exit when already looping
        if (tree.loop) {
          return !!tree.target;
        }

        // reset loop flags
        tree.posts = {};
        tree.loop = 1;

        tree.fire('begin');

        // navigate towards the target node, until stopped
        while (tree.loop) {
          if ((resuming || tree.target) && !tree.stop) {
            endEventFired = 0;
            if (lastTargetIndex != tree.target.index || !(~nextPhase | ~nextNodeIndex)) {

              // reset tracking variables
              inCurrentNode = curNode.ctx === 1;
              nextPhase = nextNodeIndex = -1;
              lastTargetIndex = tree.target.index;
              dir = lastTargetIndex - curNode.index;

              // determine where to navigate next
              if (dir) {
                if ((dir > 0 && curNode.index < 2) || !tree.target.path.indexOf(curNode.path)) {
                  if (inCurrentNode) {
                    // change to first child node
                    nextNodeIndex = curNode.firstChildIndex;
                  } else {
                    // traverse into the current node
                    nextPhase = 1;
                  }
                } else {
                  if (inCurrentNode) {
                    // traverse out of the current node
                    nextPhase = 2;
                  } else {
                    if (tree.target.path.indexOf(nodes[curNode.parentIndex].path)) {
                      // reverse direction (in order to exit a branch)
                      dir = -1;
                    }
                    if (dir > 0) {
                      if (curNode.lte == 3 || curNode.lte == 2) {
                        // change to next sibling node
                        nextNodeIndex = curNode.nextIndex;
                      } else {
                        // traverse over the current node
                        nextPhase = 3;
                      }
                    } else {
                      if (curNode.lte == 4 || curNode.lte == 2) {
                        // change to previous sibling node, if not the parent node
                        nextNodeIndex = ~curNode.previousIndex ? curNode.previousIndex : curNode.parentIndex;
                      } else {
                        // traverse backwards, over the current node
                        nextPhase = 4;
                      }
                    }
                  }
                }
              } else {
                // traverse into or on the current node
                nextPhase = inCurrentNode ? 0 : 1;
              }
            } else if (~nextNodeIndex) {
              // change - after disengaging - the current node
              if (nodeEngaged) {
                nodeEngaged = 0;
                tree.fire('release');
              } else {
                tank.currentIndex = nextNodeIndex;
                tree.fire('node', nextNodeIndex, curNode.index);
                curNode.lte = 0;
                curNode = tree.current = nodes[nextNodeIndex];
                nextNodeIndex = -1;
              }
            } else if (!nodeEngaged) {
                // engage the current node
                nodeEngaged = 1;
                tree.fire('engage');
            } else if (!inCurrentNode && !resuming && (nextPhase == 1 || nextPhase == 2)) {
              if (nextPhase == 2) {
                // clear target phase
                nextPhase = -1;
              } else {
                // enter the current node
                inCurrentNode = curNode.ctx = 1;
              }
              // fire scope in/out event
              tree.fire('scope', curNode.ctx);
            } else {
              // perform designated traversal
              if (resuming) {
                tree.fire('traversing', nextPhase);
              } else {
                curNode.lte = nextPhase;

                // reset flags when traversing "on" the current node
                if (!nextPhase) {
                  tree.target = 0;
                  tank.targetIndex = -1;
                }

                tree.fire('traverse', nextPhase);
              }

              traversalCount++;

              if (!tree.stop) {
                // end uninterupted traversal event
                tree.fire('traversed', nextPhase);
                tree.stopped = 0;
              }
              // flag stopped traversals (allows stopping during "traversed" event as well)
              tree.stopped = tree.stop;
              resuming = 0;

              if (nextPhase == 2) {
                // exit the current node
                inCurrentNode = curNode.ctx = 0;
              } else {
                nextPhase = -1;
              }
            }
          } else if (nodeEngaged) {
            // release this node
            nodeEngaged = 0;
            tree.fire('release');
          } else if (!endEventFired) {
            // end navigation
            endEventFired = 1;
            tree.fire('end');
          } else {
            // end loop
            tree.loop = 0;
          }
        }

        // execute post-loop callback functions
        for (postId in tree.posts) {
          if (tree.posts.hasOwnProperty(postId)) {
            tree.posts[postId].call(scope);
          }
        }

        return traversalCount;
      },

      // invoke package event handlers
      fire: function (eventName) {
        var
          handlerName = 'on' + eventName.charAt(0).toUpperCase() + eventName.substr(1),
          handlerArgs = arguments,
          pkgIdx = 0,
          pkgEntry,
          pkgCallback
        ;

        // execute each package's callback
        for (; pkgEntry = this.pkgs[pkgIdx]; pkgIdx++) {
          pkgCallback = pkgEntry.pkg.def[handlerName];
          if (typeof pkgCallback == 'function') {
            pkgCallback.apply(pkgEntry.inst, handlerArgs);
          }
        }
      }

    };

    // get next method up the prototype chain
    function GetSuperMethodFromKlassPackage(pkgIdx, name) {
      var
        pkg = this.pkgs[pkgIdx - 1],
        pkgInst
      ;

      // search prototype from this point in the chain
      if (pkg && name && typeof name === 'string') {
        pkgInst = new pkg.proxy();
        if (typeof pkgInst[name] === 'function') {
          return pkgInst[name];
        }
      }

      // always return a function
      return goodForNothinFunction;
    }

    // get or create package for a Panzer Klass
    function ResolveOrRegisterKlassPackage(pkgName) {
      var
        panzer = this,
        pkgIdx
      ;

      if (arguments.length) {

        if (typeof pkgName === 'string' && r_hasAlphanumeric.test(pkgName)) {

          // create non-existent package
          if (!panzer.pkgsIdx.hasOwnProperty(pkgName)) {

            // define a package definition function, which returns the private instance of it's public proxy
            function Pkg(proxyInst) {
              // return the package instance registered at this package definitions index (or false)
              if (proxyInst) {
                return proxyInst instanceof panzer.pkgs[pkgIdx].proxy && proxyInst.toString(panzer, pkgIdx);
              }
            }
            Pkg.getSuper = function (methodName) {
              return GetSuperMethodFromKlassPackage.call(panzer, pkgIdx, methodName);
            };

            // init all package members
            Pkg.init =             // initializer for this package
            Pkg.attrKey =          // what defines tag/node-attribute
            Pkg.badKey =           // what a node may not be named
            Pkg.onBegin =          // callback before navigating
            Pkg.onEnd =            // callback after navigating
            Pkg.onNode =           // callback when the current node changes
            Pkg.onEngage =         // callback before a node begins traversing and/or scoping
            Pkg.onRelease =        // callback after a node completes traversing and/or scoping
            Pkg.onScope =          // callback when a node is entered or exited
            Pkg.onTraverse =       // callback when node traversal begins
            Pkg.onTraversing =     // callback when node traversal resumes
            Pkg.onTraversed =      // callback when node traversal ends
            Pkg.prepTree =         // alter the entire tree before compilation
            Pkg.prepNode =         // alter a node during compilation
              0;
            Pkg.label = pkgName;

            function PkgProxyForKlass() {}
            // extend current public protoype chain
            PkgProxyForKlass.prototype = new panzer.KlassProxy();
            // replace public prototype and expose via this package's proxy member
            panzer.Klass.prototype = Pkg.proxy = PkgProxyForKlass.prototype;
            // replace public prototype constructor
            panzer.KlassProxy = PkgProxyForKlass;

            // define node for this package
            function PkgNodeModel() {}
            Pkg.node = PkgNodeModel.prototype;

            // register this package for this panzer, by name and index
            pkgIdx = Pkg.index = panzer.pkgsIdx[pkgName] = panzer.pkgs.push({
              name: pkgName,
              idx: panzer.pkgs.length,
              def: Pkg,
              proxy: PkgProxyForKlass,
              node: PkgNodeModel
            }) - 1;
          }
          // return package definition
          return panzer.pkgs[panzer.pkgsIdx[pkgName]].def;
        }

        return false;
      }

      // list all package names
      return panzer.pkgs.map(function (pkgCfg) {
        return pkgCfg.name;
      });
    }

    // noOp function used in various places
    function goodForNothinFunction() {}

    return Panzer;
  }

  // initialize Panzer, based on the environment
  if (inAMD) {
    define(initPanzer);
  } else if (inCJS) {
    module.exports = initPanzer(require);
  } else if (!scope.Panzer) {
    scope.Panzer = initPanzer();
  }
}(
  typeof define == 'function',
  typeof exports != 'undefined',
  Array, Object, RegExp, this
);
